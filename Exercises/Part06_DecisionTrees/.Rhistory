str(Pima.tr)
length(label)
str(data)
k_fold=10
# Create k sub-selections:
n <- nrow(data)
ind_s <- sample(1:n)
ind.L <- list()
j1 <- 1
for (i in 1:k_fold){
j2 <- (i*n) %/% k_fold
ind.L[[i]] <- ind_s[j1:j2]
j1 <- j2+1
}
ind.L
# Fit decision tree to each selection (and collect results):
confMat <- matrix(0,nrow=nlevels(label), ncol=nlevels(label))
fold <- 1
ind_fold <- ind.L[[fold]]
testDat <- data[ind_fold,]
test.solu <- label[ind_fold]
trainDat <- data[-ind_fold,]
train.solu <- label[-ind_fold]
train_fin <- cbind(y=train.solu, trainDat)
train_fin
str(train_fin)
ctree(train.solu ~ trainDat)
tr <- partykit::ctree(y ~., data = train_fin)
tr
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
show_sol <- TRUE
# Chunk 2
library(MASS)
head(Pima.tr)
str(Pima.tr)
# Chunk 3
suppressMessages(library(partykit))   # Dont show messages when loading package
set.seed(3487)
tr <- ctree(type ~ ., data = Pima.tr)
tr
# Chunk 4
plot(tr)
test_err
str(Pima.te)
pred_tr <- predict(tr, newdata=Pima.te, type='response')
# Confusion matrix:
confT <- table(pred_tr, Pima.te$type)
confT
# Test error:
missMat <- confT
diag(missMat) <- 0
test_err <- sum(missMat)/sum(confT)
test_err
graphics.off()
library(CustomFunctionsYrotha)
setUpGraph()
nicePairsPlot(Pima.tr)
d
d <- Pima.tr
d$species <- iris$Species
d$sp
d$species <- iris$Species[1:100]
nicePairsPlot(d)
nicePairsPlot(d, swtchPan = TRUE)
nicePairsPlot(d)
rm(d)
nicePairsPlot(Pima.tr)
data
head(Pima.tr)
data <- Pima.tr[, -8]
label <- Pima.tr$type
k_fold=10
# Create k sub-selections:
n <- nrow(data)
ind_s <- sample(1:n)
ind.L <- list()
j1 <- 1
for (i in 1:k_fold){
j2 <- (i*n) %/% k_fold
ind.L[[i]] <- ind_s[j1:j2]
j1 <- j2+1
}
ind.L
# Fit decision tree to each selection (and collect results):
confMat <- matrix(0,nrow=nlevels(label), ncol=nlevels(label))
fold
fold <- 1
ind_fold <- ind.L[[fold]]
testDat <- data[ind_fold,]
test.solu <- label[ind_fold]
trainDat <- data[-ind_fold,]
train.solu <- label[-ind_fold]
train_fin <- cbind(y=train.solu, trainDat)   # Needed for ctree
train_fin
head(train_fin)
str(train_fin)
rm(train_fin)
trainDat_tr <- cbind(y=train.solu, trainDat)   # Needed for ctree
head(trainDat_tr)
str(trainDat_tr)
trainDat_tr
# in one data frame for ctree
tr <- partykit::ctree(y ~., data = trainDat_tr)
tr_preds <- predict(tr, newdata = testDat)
tr_preds
tr_preds <- predict(tr, newdata = testDat)
tr_preds
confMat.fold <-  table(tr_preds, test.solu)
confMat.fold
confMat <- confMat + confMat.fold
confMat
# Calculate estimated test-error:
missMat <- confMat
diag(missMat) <- 0
missCount <- sum(missMat)
test.err <- missCount/n
test.err
confMat
missMat
missCount
n
test.err <- sum(missMat)/sum(confMat)
test.err
# Create k sub-selections:
n <- nrow(data)
ind_s <- sample(1:n)
ind.L <- list()
j1 <- 1
for (i in 1:k_fold){
j2 <- (i*n) %/% k_fold
ind.L[[i]] <- ind_s[j1:j2]
j1 <- j2+1
}
# Fit decision tree to each selection (and collect results):
confMat <- matrix(0,nrow=nlevels(label), ncol=nlevels(label))
for(fold in 1:k_fold){
ind_fold <- ind.L[[fold]]
testDat <- data[ind_fold,]
test.solu <- label[ind_fold]
trainDat <- data[-ind_fold,]
train.solu <- label[-ind_fold]
trainDat_tr <- cbind(y=train.solu, trainDat)   # Need labels and predictors
# in one data frame for ctree
tr <- partykit::ctree(y ~., data = trainDat_tr)
tr_preds <- predict(tr, newdata = testDat)
confMat.fold <-  table(tr_preds, test.solu)
confMat <- confMat + confMat.fold
}
# Calculate estimated test-error:
missMat <- confMat
diag(missMat) <- 0
test.err <- sum(missMat)/sum(confMat)
L.res <- list(k_fold=k_fold, KNN_k=KNN_k, Indices=ind.L,
confMatrix=confMat, errorRate=test.err)
return(L.res)
test.err
confMat
test.err
rm(list=ls())
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
show_sol <- TRUE
# Chunk 2
library(MASS)
head(Pima.tr)
str(Pima.tr)
# Chunk 3
suppressMessages(library(partykit))   # Dont show messages when loading package
set.seed(3487)
tr <- ctree(type ~ ., data = Pima.tr)
tr
# Chunk 4
plot(tr)
# Chunk 5
str(Pima.te)
pred_tr <- predict(tr, newdata=Pima.te, type='response')
# Confusion matrix:
confT <- table(pred_tr, Pima.te$type)
confT
# Test error:
missMat <- confT
diag(missMat) <- 0
test_err <- sum(missMat)/sum(confT)
test_err
### Adapted CV function:
tree_CV <- function(data, label, k_fold=10){
# Create k sub-selections:
n <- nrow(data)
ind_s <- sample(1:n)
ind.L <- list()
j1 <- 1
for (i in 1:k_fold){
j2 <- (i*n) %/% k_fold
ind.L[[i]] <- ind_s[j1:j2]
j1 <- j2+1
}
# Fit decision tree to each selection (and collect results):
confMat <- matrix(0,nrow=nlevels(label), ncol=nlevels(label))
for(fold in 1:k_fold){
ind_fold <- ind.L[[fold]]
testDat <- data[ind_fold,]
test.solu <- label[ind_fold]
trainDat <- data[-ind_fold,]
train.solu <- label[-ind_fold]
trainDat_tr <- cbind(y=train.solu, trainDat)   # Need labels and predictors
# in one data frame for ctree
tr <- partykit::ctree(y ~., data = trainDat_tr)
tr_preds <- predict(tr, newdata = testDat)
confMat.fold <-  table(tr_preds, test.solu)
confMat <- confMat + confMat.fold
}
# Calculate estimated test-error:
missMat <- confMat
diag(missMat) <- 0
test.err <- sum(missMat)/sum(confMat)
L.res <- list(k_fold=k_fold, KNN_k=KNN_k, Indices=ind.L,
confMatrix=confMat, errorRate=test.err)
return(L.res)
}
### Apply function:
Pima.comb <- rbind(Pima.tr, Pima.te)
str(Pima.comb)
str(Pima.tr)
str(Pima.t3)
str(Pima.te)
tree_CV(data = Pima.comb[, -8], label = Pima.comb$type, k_fold = 10)
### Adapted CV function:
tree_CV <- function(data, label, k_fold=10){
# Create k sub-selections:
n <- nrow(data)
ind_s <- sample(1:n)
ind.L <- list()
j1 <- 1
for (i in 1:k_fold){
j2 <- (i*n) %/% k_fold
ind.L[[i]] <- ind_s[j1:j2]
j1 <- j2+1
}
# Fit decision tree to each selection (and collect results):
confMat <- matrix(0,nrow=nlevels(label), ncol=nlevels(label))
for(fold in 1:k_fold){
ind_fold <- ind.L[[fold]]
testDat <- data[ind_fold,]
test.solu <- label[ind_fold]
trainDat <- data[-ind_fold,]
train.solu <- label[-ind_fold]
trainDat_tr <- cbind(y=train.solu, trainDat)   # Need labels and predictors
# in one data frame for ctree
tr <- partykit::ctree(y ~., data = trainDat_tr)
tr_preds <- predict(tr, newdata = testDat)
confMat.fold <-  table(tr_preds, test.solu)
confMat <- confMat + confMat.fold
}
# Calculate estimated test-error:
missMat <- confMat
diag(missMat) <- 0
test.err <- sum(missMat)/sum(confMat)
L.res <- list(k_fold=k_fold, confMatrix=confMat, errorRate=test.err)
return(L.res)
}
### Apply function:
Pima.comb <- rbind(Pima.tr, Pima.te)   # Combine data sets
tree_CV(data = Pima.comb[, -8], label = Pima.comb$type, k_fold = 10)
rm(list=ls())
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
show_sol <- TRUE
# Chunk 2
library(MASS)
head(Pima.tr)
str(Pima.tr)
# Chunk 3
suppressMessages(library(partykit))   # Dont show messages when loading package
set.seed(3487)
tr <- ctree(type ~ ., data = Pima.tr)
tr
# Chunk 4
plot(tr)
# Chunk 5
str(Pima.te)
pred_tr <- predict(tr, newdata=Pima.te, type='response')
# Confusion matrix:
confT <- table(pred_tr, Pima.te$type)
confT
# Test error:
missMat <- confT
diag(missMat) <- 0
test_err <- sum(missMat)/sum(confT)
test_err
# Chunk 6
### Adapted CV function:
tree_CV <- function(data, label, k_fold=10){
# Create k sub-selections:
n <- nrow(data)
ind_s <- sample(1:n)
ind.L <- list()
j1 <- 1
for (i in 1:k_fold){
j2 <- (i*n) %/% k_fold
ind.L[[i]] <- ind_s[j1:j2]
j1 <- j2+1
}
# Fit decision tree to each selection (and collect results):
confMat <- matrix(0,nrow=nlevels(label), ncol=nlevels(label))
for(fold in 1:k_fold){
ind_fold <- ind.L[[fold]]
testDat <- data[ind_fold,]
test.solu <- label[ind_fold]
trainDat <- data[-ind_fold,]
train.solu <- label[-ind_fold]
trainDat_tr <- cbind(y=train.solu, trainDat)   # Need labels and predictors
# in one data frame for ctree
tr <- partykit::ctree(y ~., data = trainDat_tr)
tr_preds <- predict(tr, newdata = testDat)
confMat.fold <-  table(tr_preds, test.solu)
confMat <- confMat + confMat.fold
}
# Calculate estimated test-error:
missMat <- confMat
diag(missMat) <- 0
test.err <- sum(missMat)/sum(confMat)
L.res <- list(k_fold=k_fold, confMatrix=confMat, errorRate=test.err)
return(L.res)
}
### Apply function:
Pima.comb <- rbind(Pima.tr, Pima.te)   # Combine data sets
tree_CV(data = Pima.comb[, -8], label = Pima.comb$type, k_fold = 10)
nicePairsPlot(Pima.comb)
nicePairsPlot(Pima.comb, loess = TRUE)
nicePairsPlot(Pima.comb, loess = TRUE, catVar = Pima.comb$type)
tree_CV(data = Pima.comb[, -8], label = Pima.comb$type, k_fold = 10)
tree_CV(data = Pima.comb[, -8], label = Pima.comb$type, k_fold = 10)
set.seed(2983)
tree_CV(data = Pima.comb[, -8], label = Pima.comb$type, k_fold = 10)
tree_CV(data = Pima.comb[, -8], label = Pima.comb$type, k_fold = 10)
set.seed(2983)
tree_CV(data = Pima.comb[, -8], label = Pima.comb$type, k_fold = 10)
set.seed(2983)
tree_CV(data = Pima.comb[, -8], label = Pima.comb$type, k_fold = 10)
str(Pima.comb)
frs <- cforest(type ~ ., data = Pima.comb)
?cforest
frs <- cforest(type ~ ., data = Pima.comb, ntree = 1000)
library(beepr)
beep()
predict(frs, OOB = TRUE)
frs_p <- predict(frs, OOB = TRUE)
frs_p
confMat
confM
confM <- table(frs_p, Pima.comb$type)
confM
missm <- confM
diag(missm) <- 0
sum(missm)/sum(confM)
sum(missm)/sum(confM)
frs <- cforest(type ~ ., data = Pima.comb, ntree = 500)
frs_p <- predict(frs, OOB = TRUE)
confM <- table(frs_p, Pima.comb$type)
missm <- confM
diag(missm) <- 0
sum(missm)/sum(confM)
frs <- cforest(type ~ ., data = Pima.tr, ntree = 500)
frs_p <- predict(frs, OOB = TRUE)
confM <- table(frs_p, Pima.tr$type)
missm <- confM
diag(missm) <- 0
sum(missm)/sum(confM)
confM
confT
frs_p <- predict(frs, newdata = Pima.te)
confM <- table(frs_p, Pima.te$type)
missm <- confM
diag(missm) <- 0
sum(missm)/sum(confM)
confM
confM
confT
getwd()
rm(list=ls())
load('./dat_smoking.rda')
ls()
head(dat_smoking)
nicePairsPlot(dat_smoking)
sum(missm)/sum(confM)
ls()
nicePairsPlot(dat_smoking, loess = TRUE)
ls()
frs <- cforest(alcohol_per_month ~ ., data = dat_smoking, ntree = 500)
Pima.te
nicePairsPlot(Pima.tr)
?Pima.te
head(Pima.tr)
tr_glu <- ctree(glu ~ ., data = Pima.tr)
plot(tr_glu)
nicePairsPlot(Pima.tr)
lm(glu ~ ., Pima.tr)
summary(lm(glu ~ ., Pima.tr))
tr_glu <- ctree(glu ~ ., data = Pima.tr)
plot(tr_glu)
str(Pima.tr)
tr
suppressMessages(library(partykit))   # Dont show messages when loading package
set.seed(3487)
tr <- ctree(type ~ ., data = Pima.tr)
tr
pred_tr <- predict(tr, newdata=Pima.te, type='response')
pred_tr <- predict(tr, newdata=Pima.te)
predict(tr, newdata=Pima.te)
predict(tr, newdata=Pima.te, type='response')
predict(tr, newdata=Pima.te, type='prob')
ctree.iris <- ctree(Sepal.Length ~., data=iris)  # fit regression tree
predict(ctree.iris, newdata=iris, type='response')
pred_glu <- predict(tr_glu, newdata = Pima.te)
pred_glu
class(tr_glu)
?predict.party
?predict_party
predict_party
predict.party
pred_glu <- predict(tr_glu, newdata = Pima.te)
pred_glu
plot(x = pred_glu, y = Pima.te$glu, ylab = 'true glu values', xlab = 'predicted glu values')
pred_glu <- predict(tr_glu, newdata = Pima.te)
### MSE:
pred_glu - Pima.te$glu
### MSE:
(pred_glu - Pima.te$glu)^2
### MSE:
mean((pred_glu - Pima.te$glu)^2)
### MSE:
mse_tree <- mean((pred_glu - Pima.te$glu)^2)
mse_tree
lm_glu <- lm(glu ~ ., data = Pima.tr)
summary(lm_glu)
predlm_glu <- predict(lm_glu, newdata = Pima.te)
predlm_glu
mse_lm <- mean((predlm_glu - Pima.te$glu)^2)
mse_lm
mse_tree
plot(x = predlm_glu, y = Pima.te$glu)
c('MSE_tree'=mse_tree, 'MSE_lm'=mse_lm)
for_glu <- cforest(glu ~., data = Pima.tr, ntree = 1000)
beep()
pred_for <- predict(for_glu, newdata = Pima.te)
pred_for
mse_for <- mean((pred_for - Pima.te$glu)^2)
mse_for
plot(pred_for, Pima.te$glu)
nicePairsPlot(Pima.tr)
d <- Pima.tr[, c("bp", "glu", "age")]
nice3DPlot(d)
nice3DPlot(standizDat(d))
nice3DPlot(standizDat(d), plotFit = 'lin')
rm(list=ls8)
rm(list=ls())
ls()
load("/home/yrothacher/Desktop/PostDoc_Unterlagen/Arbeit/Workshops/myWorkshops/Swiss_Psychological_Society_2022/Machine_Learning_Workshop/myMaterial/Slides/dat_smoking.rda")
ls()
nicePairsPlot(dat_smoking)
ls()
str(dat_smoking)
colnames(dat_smoking)
paste(colnames(dat_smoking))
paste(colnames(dat_smoking), collapse = '')
paste(colnames(dat_smoking), collapse = ' ')
paste(colnames(dat_smoking), collapse = ', ')
ls()
library(MASS)
d <- rbind(Pima.tr, Pima.te)   # Combine data sets
head(d)
str(d)
library(CustomFunctionsYrotha)
nice3DPlot(d[, c("bp", "glu", "age")], catVar = d$type)
d <- standizDat(d)
nice3DPlot(d[, c("bp", "glu", "age")], catVar = d$type)
d <- rbind(Pima.tr, Pima.te)   # Combine data sets
d <- standizDat(d, chngName = FALSE)
library(CustomFunctionsYrotha)
nice3DPlot(d[, c("bp", "glu", "age")], catVar = d$type)
nice3DPlot(d[, c("bp", "glu", "age")], catVar = d$type, plotFit = 'lin')
nice3DPlot(d[, c("bp", "glu", "age")], catVar = d$type, plotFit = 'int')
nice3DPlot(d[, c("bp", "glu", "age")], catVar = d$type, plotFit = 'int2')
nice3DPlot(d[, c("bp", "glu", "age")], catVar = d$type, plotFit = 'int3')
library(MASS)
head(Pima.tr)
str(Pima.tr)
suppressMessages(library(partykit))   # Dont show messages when loading package
set.seed(3487)
tr <- ctree(type ~ ., data = Pima.tr)
tr
library(CustomFunctionsYrotha)
setUpGraph()
tr_glu <- ctree(glu ~ ., data = Pima.tr)
plot(tr_glu)
head(Pima.tr)
nicePairsPlot(Pima.tr)
nicePairsPlot(Pima.tr, loess = TRUE)
nice3DPlot(Pima.tr[, c("age", "glu", "bp")])
d <- Pima.tr[, c("age", "glu", "bp")]
head(d)
d <- Pima.tr[, c("age", "glu", "bp", "type")]
head(d)
str(d)
d <- standizDat(d, chngName = FALSE)
head(d)
str(d)
nice3DPlot(d[, -4], catVar = d$type)
nice3DPlot(d[, -4], catVar = d$type, plotFit = 'lin')
nice3DPlot(d[, -4], catVar = d$type, plotFit = 'int')
nice3DPlot(d[, -4], catVar = d$type, plotFit = 'int2')
