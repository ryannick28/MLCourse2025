mean(tst_h0 > t_or)
### Empirical p-value (one sided):
mean(tst_h0 > t_or)
1+1
3*3
1+1
2*2
2/2
a <- 3
a + 1
bbbb <- 20
bbbb + a
x <- seq(from=1, to=10, length.out=100)
x
y <- 0
dat <- data.frame(x, y)
dat
dat$y[dat$x>5] <- 1
dat
library(CustomFunctionsYrotha)
setUpGraph()
plot(y ~x, dat)
log_fit <- glm(y ~x, dat, family='binomial')
log_fit
dat
plot(y ~x, dat)
summary(log_fit)
a <- rnorm(1000, sd=0.00001)
b <- rnorm(1000, sd=10)
hist(c(a,b))
qqplot(c(a,b))
qqnorm(c(a,b))
library(CustomFunctionsYrotha)
dat <- mmdgp()
head(dat)
str(dat)
library(lmerTest)
lmer(y ~ age + (age|id), data=dat)
dat <- mmdgp(n = 100, nC = 1)
lmer(y ~ age + (age|id), data=dat)
lmer(y ~ age + (1|id), data=dat)
lmer(y ~ age + (age|id), data=dat)
lmer(y ~ (age|id), data=dat)
lmer(y ~ age + (age|id), data=dat)
dat <- mmdgp(n = 100, nC = 1)
lmer(y ~ age + (age|id), data=dat)
lmer(y ~ age + (1|id), data=dat)
str(dat)
head(dat)
lmer(y ~ day + (day|id), data=dat)
str(dat)
dat$day <- as.numeric(dat$day)
lmer(y ~ day + (day|id), data=dat)
lmer(y ~  (day|id), data=dat)
lmer(y ~  day + (day|id), data=dat)
head(dat)
str(dat)
lmer(y ~  day + (day|id), data=dat)
lmer(y ~  day + (1+day|id), data=dat)
lmer(y ~ 1+  day + (1+day|id), data=dat)
?hclust
library(cluster)
1+1
2*3
1+100
1+100
3*3
a <- 33
a*100
vec1 <- c(20, 122, 39)
vec1
iris
?kmeans
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
show_sol <- FALSE
# Chunk 2
load('wine_data.rda')
setwd("/home/yrothacher/Desktop/PostDoc_Unterlagen/Arbeit/Workshops/myWorkshops/Blockkurs_IntroToMachineLearning_FS23/Exercises/IMLR_Part03_KMeans/")
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
show_sol <- FALSE
# Chunk 2
load('wine_data.rda')
head(wine_red, 3)   # Only showing 3 rows to save space
head(wine_white, 3)
str(wine_red)
str(wine_white)
# Chunk 3
wine_red$colour <- 'red'
wine_white$colour <- 'white'
head(wine_white, 3)
# Chunk 4
wines <- rbind(wine_red, wine_white)
dim(wines)
# Chunk 5
wines$colour <- factor(wines$colour)
# Chunk 6
wines_nocol <- wines
wines_nocol$colour <- NULL
# Chunk 7
wines_nocol <- data.frame(scale(wines_nocol))
# Chunk 8
set.seed(1211)
km_2 <- kmeans(wines_nocol, centers = 2)
library(cluster)
plot(silhouette(x = km_2$cluster, dist = dist(wines_nocol)))
silhouette(x = km_2$cluster, dist = dist(wines_nocol))
plot.new()
plot(silhouette(x = km_2$cluster, dist = dist(wines_nocol)))
library(CustomFunctionsYrotha)
plot(silhouette(x = km_2$cluster, dist = dist(wines_nocol)))
setUpGraph()
plot(silhouette(x = km_2$cluster, dist = dist(wines_nocol)))
setUpGraph
dev.new()
plot(silhouette(x = km_2$cluster, dist = dist(wines_nocol)))
?dev.new
plot(silhouette(x = km_2$cluster, dist = dist(wines_nocol)))
dev.new()
plot(silhouette(x = km_2$cluster, dist = dist(wines_nocol)))
plot(silhouette(x = km_2$cluster, dist = dist(wines_nocol)))
plot(silhouette(x = km_2$cluster, dist = dist(wines_nocol)))
graphics.off()
plot(silhouette(x = km_2$cluster, dist = dist(wines_nocol)))
plot(silhouette(x = km_2$cluster, dist = dist(wines_nocol)), border = NA)
plot(silhouette(x = km_2$cluster, dist = dist(wines_nocol)))
plot(silhouette(x = km_2$cluster, dist = dist(wines_nocol)), border = NA)
library(CustomFunctionsYrotha)
setUpGraph()
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
show_sol <- FALSE
# Chunk 2
load('wine_data.rda')
head(wine_red, 3)   # Only showing 3 rows to save space
head(wine_white, 3)
str(wine_red)
str(wine_white)
# Chunk 3
wine_red$colour <- 'red'
wine_white$colour <- 'white'
head(wine_white, 3)
# Chunk 4
wines <- rbind(wine_red, wine_white)
dim(wines)
# Chunk 5
wines$colour <- factor(wines$colour)
# Chunk 6
wines_nocol <- wines
wines_nocol$colour <- NULL
# Chunk 7
wines_nocol <- data.frame(scale(wines_nocol))
# Chunk 8
set.seed(1211)
km_2 <- kmeans(wines_nocol, centers = 2)
library(cluster)
ls()
head(wines_nocol)
str(wines)
nicePairsPlot(wines)
nicePairsPlot(wines, cex.diag =0.5)
nicePairsPlot(wines, cex.diag =1, cex.offdiag = 0.8)
nicePairsPlot(wines, cex.diag =1, cex.offdiag = 0.4)
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
show_sol <- FALSE
# Chunk 2
load('wine_data.rda')
head(wine_red, 3)   # Only showing 3 rows to save space
head(wine_white, 3)
str(wine_red)
str(wine_white)
# Chunk 3
wine_red$colour <- 'red'
wine_white$colour <- 'white'
head(wine_white, 3)
# Chunk 4
wines <- rbind(wine_red, wine_white)
dim(wines)
wines$colour <- factor(wines$colour)
library(CustomFunctionsYrotha)
setUpGraph()
nicePairsPlot(wines, cex.diag =1, cex.offdiag = 0.4)
### Libraries:
library(CustomFunctionsYrotha)
### Parameters:
N <- 10
b0 <- 1
b1 <- 1
b2 <- -1
serr <- 0.4
### Prepare x values for plotting:
xp <- seq(from=-5, to=5, length.out=500)
yp_t <- b0 + b1*xp + b2*xp^2
### Run loop to show progression:
set.seed(1129)
mdl <- list()   # List with models to plot
show_un <- TRUE   # Show under fitting or overfitting
showPred <- TRUE   # Show predictions
slp <- 2   # Pause how long between plots
nRuns <- 50   # How many runs
i <- 1
### Generate new data:
if(show_un){
x <- runif(N, min = -1, max = 1)
}else{
x <- runif(N, min = -2, max = 2)   # Otherwise extrapolation makes plot uglier
}
y <- b0 + b1*x + b2*x^2 + rnorm(N, sd=serr)
### Fit model:
if(show_un){
mdl[[i]] <- lm(y ~ x)
#mdl[[i]] <- lm(y ~ x + I(x^2))   # Correct model
}else{
mdl[[i]] <- lm(y ~ x + I(x^2) + I(x^3) + I(x^4) + + I(x^5) + I(x^6) )
}
### Plot:
plot(y~x, xlim=c(-1, 1), ylim=c(-2, 2))
### Add curves:
lines(x = xp, y = yp_t, col='green', lwd=4)   # True curve
if(showPred){
### Show and collect predictions of so far collected models:
m_prd <- lapply(mdl, function(m){
preds <- predict(m, newdata = data.frame(x=xp))
lines(x = xp, y = preds, col='blue')
return(preds)
})
}
i <- 2
### Generate new data:
if(show_un){
x <- runif(N, min = -1, max = 1)
}else{
x <- runif(N, min = -2, max = 2)   # Otherwise extrapolation makes plot uglier
}
y <- b0 + b1*x + b2*x^2 + rnorm(N, sd=serr)
### Fit model:
if(show_un){
mdl[[i]] <- lm(y ~ x)
#mdl[[i]] <- lm(y ~ x + I(x^2))   # Correct model
}else{
mdl[[i]] <- lm(y ~ x + I(x^2) + I(x^3) + I(x^4) + + I(x^5) + I(x^6) )
}
### Plot:
plot(y~x, xlim=c(-1, 1), ylim=c(-2, 2))
### Add curves:
lines(x = xp, y = yp_t, col='green', lwd=4)   # True curve
if(showPred){
### Show and collect predictions of so far collected models:
m_prd <- lapply(mdl, function(m){
preds <- predict(m, newdata = data.frame(x=xp))
lines(x = xp, y = preds, col='blue')
return(preds)
})
}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#   OVER AND UNDERFITTING   ####
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if(TRUE){
### Parameters:
N <- 10
b0 <- 1
b1 <- 1
b2 <- -1
serr <- 0.4
### Prepare x values for plotting:
xp <- seq(from=-5, to=5, length.out=500)
yp_t <- b0 + b1*xp + b2*xp^2
### Run loop to show progression:
set.seed(1129)
mdl <- list()   # List with models to plot
show_un <- TRUE   # Show under fitting or overfitting
showPred <- TRUE   # Show predictions
slp <- 0.2   # Pause how long between plots
nRuns <- 50   # How many runs
for(i in 1:nRuns){
### Generate new data:
if(show_un){
x <- runif(N, min = -1, max = 1)
}else{
x <- runif(N, min = -2, max = 2)   # Otherwise extrapolation makes plot uglier
}
y <- b0 + b1*x + b2*x^2 + rnorm(N, sd=serr)
### Fit model:
if(show_un){
mdl[[i]] <- lm(y ~ x)
#mdl[[i]] <- lm(y ~ x + I(x^2))   # Correct model
}else{
mdl[[i]] <- lm(y ~ x + I(x^2) + I(x^3) + I(x^4) + + I(x^5) + I(x^6) )
}
### Plot:
plot(y~x, xlim=c(-1, 1), ylim=c(-2, 2))
### Add curves:
lines(x = xp, y = yp_t, col='green', lwd=4)   # True curve
if(showPred){
### Show and collect predictions of so far collected models:
m_prd <- lapply(mdl, function(m){
preds <- predict(m, newdata = data.frame(x=xp))
lines(x = xp, y = preds, col='blue')
return(preds)
})
}
### Wait for a moment:
Sys.sleep(slp)
}
### Show mean curve:
yp_mn <- apply(do.call(rbind, m_prd), 2, mean)
lines(x = xp, y = yp_t, col='green', lwd=4)   # True curve
lines(x = xp, y = yp_mn, col='red', lwd=4)
}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#   OVER AND UNDERFITTING   ####
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if(TRUE){
### Parameters:
N <- 10
b0 <- 1
b1 <- 1
b2 <- -1
serr <- 0.4
### Prepare x values for plotting:
xp <- seq(from=-5, to=5, length.out=500)
yp_t <- b0 + b1*xp + b2*xp^2
### Run loop to show progression:
set.seed(1129)
mdl <- list()   # List with models to plot
show_un <- FALSE   # Show under fitting or overfitting
showPred <- TRUE   # Show predictions
slp <- 0.2   # Pause how long between plots
nRuns <- 50   # How many runs
for(i in 1:nRuns){
### Generate new data:
if(show_un){
x <- runif(N, min = -1, max = 1)
}else{
x <- runif(N, min = -2, max = 2)   # Otherwise extrapolation makes plot uglier
}
y <- b0 + b1*x + b2*x^2 + rnorm(N, sd=serr)
### Fit model:
if(show_un){
mdl[[i]] <- lm(y ~ x)
#mdl[[i]] <- lm(y ~ x + I(x^2))   # Correct model
}else{
mdl[[i]] <- lm(y ~ x + I(x^2) + I(x^3) + I(x^4) + + I(x^5) + I(x^6) )
}
### Plot:
plot(y~x, xlim=c(-1, 1), ylim=c(-2, 2))
### Add curves:
lines(x = xp, y = yp_t, col='green', lwd=4)   # True curve
if(showPred){
### Show and collect predictions of so far collected models:
m_prd <- lapply(mdl, function(m){
preds <- predict(m, newdata = data.frame(x=xp))
lines(x = xp, y = preds, col='blue')
return(preds)
})
}
### Wait for a moment:
Sys.sleep(slp)
}
### Show mean curve:
yp_mn <- apply(do.call(rbind, m_prd), 2, mean)
lines(x = xp, y = yp_t, col='green', lwd=4)   # True curve
lines(x = xp, y = yp_mn, col='red', lwd=4)
}
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#   OVER AND UNDERFITTING   ####
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if(TRUE){
### Parameters:
N <- 10
b0 <- 1
b1 <- 1
b2 <- -1
serr <- 0.4
### Prepare x values for plotting:
xp <- seq(from=-5, to=5, length.out=500)
yp_t <- b0 + b1*xp + b2*xp^2
### Run loop to show progression:
set.seed(1129)
mdl <- list()   # List with models to plot
show_un <- FALSE   # Show under fitting or overfitting
showPred <- TRUE   # Show predictions
slp <- 0.2   # Pause how long between plots
nRuns <- 50   # How many runs
for(i in 1:nRuns){
### Generate new data:
if(show_un){
x <- runif(N, min = -1, max = 1)
}else{
x <- runif(N, min = -2, max = 2)   # Otherwise extrapolation makes plot uglier
}
y <- b0 + b1*x + b2*x^2 + rnorm(N, sd=serr)
### Fit model:
if(show_un){
mdl[[i]] <- lm(y ~ x)
mdl[[i]] <- lm(y ~ x + I(x^2))   # Correct model
}else{
mdl[[i]] <- lm(y ~ x + I(x^2) + I(x^3) + I(x^4) + + I(x^5) + I(x^6) )
}
### Plot:
plot(y~x, xlim=c(-1, 1), ylim=c(-2, 2))
### Add curves:
lines(x = xp, y = yp_t, col='green', lwd=4)   # True curve
if(showPred){
### Show and collect predictions of so far collected models:
m_prd <- lapply(mdl, function(m){
preds <- predict(m, newdata = data.frame(x=xp))
lines(x = xp, y = preds, col='blue')
return(preds)
})
}
### Wait for a moment:
Sys.sleep(slp)
}
### Show mean curve:
yp_mn <- apply(do.call(rbind, m_prd), 2, mean)
lines(x = xp, y = yp_t, col='green', lwd=4)   # True curve
lines(x = xp, y = yp_mn, col='red', lwd=4)
}
# Date: 15-03-2023
#%%%%%%%%%%%%%#
#   To Show   #
#%%%%%%%%%%%%%#
### Libraries:
library(CustomFunctionsYrotha)
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#   OVER AND UNDERFITTING   ####
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if(TRUE){
### Parameters:
N <- 10
b0 <- 1
b1 <- 1
b2 <- -1
serr <- 0.4
### Prepare x values for plotting:
xp <- seq(from=-5, to=5, length.out=500)
yp_t <- b0 + b1*xp + b2*xp^2
### Run loop to show progression:
set.seed(1129)
mdl <- list()   # List with models to plot
show_un <- TRUE   # Show under fitting or overfitting
showPred <- TRUE   # Show predictions
slp <- 0.2   # Pause how long between plots
nRuns <- 50   # How many runs
for(i in 1:nRuns){
### Generate new data:
if(show_un){
x <- runif(N, min = -1, max = 1)
}else{
x <- runif(N, min = -2, max = 2)   # Otherwise extrapolation makes plot uglier
}
y <- b0 + b1*x + b2*x^2 + rnorm(N, sd=serr)
### Fit model:
if(show_un){
mdl[[i]] <- lm(y ~ x)
mdl[[i]] <- lm(y ~ x + I(x^2))   # Correct model
}else{
mdl[[i]] <- lm(y ~ x + I(x^2) + I(x^3) + I(x^4) + + I(x^5) + I(x^6) )
}
### Plot:
plot(y~x, xlim=c(-1, 1), ylim=c(-2, 2))
### Add curves:
lines(x = xp, y = yp_t, col='green', lwd=4)   # True curve
if(showPred){
### Show and collect predictions of so far collected models:
m_prd <- lapply(mdl, function(m){
preds <- predict(m, newdata = data.frame(x=xp))
lines(x = xp, y = preds, col='blue')
return(preds)
})
}
### Wait for a moment:
Sys.sleep(slp)
}
### Show mean curve:
yp_mn <- apply(do.call(rbind, m_prd), 2, mean)
lines(x = xp, y = yp_t, col='green', lwd=4)   # True curve
lines(x = xp, y = yp_mn, col='red', lwd=4)
}
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
show_sol <- TRUE
# Chunk 2
load('wine_data.rda')
head(wine_red, 3)   # Only showing 3 rows to save space
head(wine_white, 3)
str(wine_red)
str(wine_white)
# Chunk 3
wine_red$colour <- 'red'
wine_white$colour <- 'white'
head(wine_white, 3)
# Chunk 4
wines <- rbind(wine_red, wine_white)
dim(wines)
# Chunk 5
wines$colour <- factor(wines$colour)
# Chunk 6
wines_nocol <- wines
wines_nocol$colour <- NULL
# Chunk 7
wines_nocol <- data.frame(scale(wines_nocol))
# Chunk 8
set.seed(1211)
km_2 <- kmeans(wines_nocol, centers = 2)
library(cluster)
plot(silhouette(x = km_2$cluster, dist = dist(wines_nocol)))
plot(silhouette(x = km_2$cluster, dist = dist(wines_nocol), border=NA))
plot(silhouette(x = km_2$cluster, dist = dist(wines_nocol)), border=NA)
