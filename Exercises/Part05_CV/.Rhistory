indL
lapply(indL, length)
sapply(indL, length)
n
k
k_fold <- 17
indL <- suppressWarnings(split(inds, f = 1:k_fold))
indL
sapply(indL, length)
indL
### Run KNN on each selection:
confMat <- matrix(0,nrow=nlevels(label), ncol=nlevels(label))
confMat
### Run KNN on each selection:
confMat <- matrix(0, nrow=nlevels(label), ncol=nlevels(label))
confMat
i <- 1
ind_fold <- indL[[i]]
ind_fold
indL
ind_fold
testDat <- data[ind_fold,]
testDat
trainDat <- data[-ind_fold,]
trainDat
test.solu <- label[ind_fold]
train.solu <- label[-ind_fold]
train.solu
test.solu
trainDat
testDat
knn.pred <- class::knn(train = trainDat, cl = train.solu,
test = testDat, k = KNN_k)
confMat.fold <-  table(test.solu, knn.pred)
confMat.fold
confMat <- confMat + confMat.fold
confMat
### Run KNN on each selection:
confMat <- matrix(0, nrow=nlevels(label), ncol=nlevels(label))
for(i in 1:k_fold){
ind_fold <- indL[[i]]
testDat <- data[ind_fold,]
trainDat <- data[-ind_fold,]
test.solu <- label[ind_fold]
train.solu <- label[-ind_fold]
knn.pred <- class::knn(train = trainDat, cl = train.solu,
test = testDat, k = KNN_k)
confMat.fold <-  table(test.solu, knn.pred)
confMat <- confMat + confMat.fold
}
confMat
### Calculate estimated test-error:
missMat <- confMat
diag(missMat) <- 0
missCount <- sum(missMat)
test.err <- missCount/n
test.err
L.res <- list(k_fold=k_fold, KNN_k=KNN_k, Indices=indL,
confMatrix=confMat, errorRate=test.err)
L.res
L.res <- list(confMatrix=confMat, errorRate=test.err)
L.res
rm(list=ls())
### Try out function:
dat <- iris[,-5]
label <- iris$Species
KNN_crossVal(data = dat, label = label, k_fold = 10, KNN_k = 5)
### Create function:
KNN_crossVal <- function(data, label, k_fold=10, KNN_k=1){
stopifnot(nrow(data)==length(label), is.factor(label),
1<k_fold, k_fold<=nrow(data), KNN_k<=nrow(data))
### Create k sub-selections:
n <- nrow(data)
inds <- sample(1:n)
indL <- suppressWarnings(split(inds, f = 1:k_fold))
### Run KNN on each selection:
confMat <- matrix(0, nrow=nlevels(label), ncol=nlevels(label))
for(i in 1:k_fold){
ind_fold <- indL[[i]]
testDat <- data[ind_fold,]
trainDat <- data[-ind_fold,]
test.solu <- label[ind_fold]
train.solu <- label[-ind_fold]
knn.pred <- class::knn(train = trainDat, cl = train.solu,
test = testDat, k = KNN_k)
confMat.fold <-  table(test.solu, knn.pred)
confMat <- confMat + confMat.fold
}
### Calculate estimated test-error:
missMat <- confMat
diag(missMat) <- 0
missCount <- sum(missMat)
test.err <- missCount/n
L.res <- list(confMatrix=confMat, errorRate=test.err)
return(L.res)
}
### Try out function:
dat <- iris[,-5]
label <- iris$Species
KNN_crossVal(data = dat, label = label, k_fold = 10, KNN_k = 5)
kDivide.Vec <- function(vec, k){
n <- length(vec)
ind_s <- sample(1:n)
L <- split(ind_s, f=1:k)
return(L)
}
kDivide.Vec
set.seed(48484)
vec <- rnorm(n = 8)
kDivide.Vec(vec)
set.seed(48484)
vec <- rnorm(n = 8)
kDivide.Vec(vec, k = 3)
rm(list=ls())
### Try out function:
dat <- iris[,-5]
label <- iris$Species
asArguments("data = dat, label = label, k_fold = 10, KNN_k = 5")
### Check input:
stopifnot(nrow(data)==length(label), is.factor(label),
1<k_fold, k_fold<=nrow(data), KNN_k<=nrow(data))
### Create k sub-selections:
n <- nrow(data)
inds <- sample(1:n)
indL <- suppressWarnings(split(inds, f = 1:k_fold))
indL
### Run KNN on each selection:
preds <- list()   # Create empty list
i <- 1
### Extract fold data:
ind_fold <- indL[[i]]
testDat <- data[ind_fold,]
trainDat <- data[-ind_fold,]
test.solu <- label[ind_fold]
train.solu <- label[-ind_fold]
ind_fold
testDat
trainDat
test.solu
train.solu
### Make predictions:
class::knn(train = trainDat, cl = train.solu,
test = testDat, k = KNN_k)
### Make predictions:
preds[[i]] <- class::knn(train = trainDat, cl = train.solu,
test = testDat, k = KNN_k)
preds
### Make predictions:
knnprd <- class::knn(train = trainDat, cl = train.solu,
test = testDat, k = KNN_k)
knnprd
### Run KNN on each selection:
preds <- list()   # Create empty list
preds
knnprd
### Combine true solution with predictions:
cbind(test.solu, knnprd)
test.solu
### Combine true solution with predictions:
data.frame(test.solu, knnprd)
### Combine true solution with predictions:
preds[[i]] <- data.frame(test.solu, knnprd)
preds
### Run KNN on each selection:
preds <- list()   # Create empty list
for(i in 1:k_fold){
### Extract fold data:
ind_fold <- indL[[i]]
testDat <- data[ind_fold,]
trainDat <- data[-ind_fold,]
test.solu <- label[ind_fold]
train.solu <- label[-ind_fold]
### Make predictions:
knnprd <- class::knn(train = trainDat, cl = train.solu,
test = testDat, k = KNN_k)
### Combine true solution with predictions:
preds[[i]] <- data.frame(test.solu, knnprd)
}
preds
### Merge into one data frame:
do.call(rbind, preds)
### Merge into one data frame:
str(do.call(rbind, preds))
unsplit(preds)
unlist(preds)
### Merge into one data frame:
do.call(rbind, preds)
preds
### Merge into one data frame:
### In one command:
#do.call(rbind, preds)
### Using a for loop:
predmrg <- preds[[1]]
predmrg
i <- 2
length(preds)
predmrg <- rbind(predmrg, preds[[i]])
predmrg
i
### Merge into one data frame:
### In one command:
#do.call(rbind, preds)
### Using a for loop:
predmrg <- preds[[1]]
for(i in 2:length(preds)){
predmrg <- rbind(predmrg, preds[[i]])
}
predmrg
a <- do.call(rbind, preds)
a
table(a)
### Merge into one data frame:
### In one command:
#do.call(rbind, preds)
### Using a for loop:
predmrg <- preds[[1]]
for(i in 2:length(preds)){
predmrg <- rbind(predmrg, preds[[i]])
}
predmrg
table(a)
table(predmrg)
### Confusion matrix:
table(predmrg)
### Confusion matrix:
confm <- table(predmrg)
confm
predmrg
### Check input:
stopifnot(nrow(data)==length(label), is.factor(label),
1<k_fold, k_fold<=nrow(data), KNN_k<=nrow(data))
### Create k sub-selections:
n <- nrow(data)
inds <- sample(1:n)
indL <- suppressWarnings(split(inds, f = 1:k_fold))
### Run KNN on each selection:
preds <- list()   # Create empty list
for(i in 1:k_fold){
### Extract fold data:
ind_fold <- indL[[i]]
testDat <- data[ind_fold,]
trainDat <- data[-ind_fold,]
test.solu <- label[ind_fold]
train.solu <- label[-ind_fold]
### Make predictions:
knnprd <- class::knn(train = trainDat, cl = train.solu,
test = testDat, k = KNN_k)
### Combine true solution with predictions:
preds[[i]] <- data.frame("TrueValue"=test.solu, "Prediction"=knnprd)
}
preds
predmrg <- do.call(rbind, preds)
### Confusion matrix:
confm <- table(predmrg)
confm
### Check input:
stopifnot(nrow(data)==length(label), is.factor(label),
1<k_fold, k_fold<=nrow(data), KNN_k<=nrow(data))
### Create k sub-selections:
n <- nrow(data)
inds <- sample(1:n)
indL <- suppressWarnings(split(inds, f = 1:k_fold))
### Run KNN on each selection:
preds <- list()   # Create empty list
for(i in 1:k_fold){
### Extract fold data:
ind_fold <- indL[[i]]
testDat <- data[ind_fold,]
trainDat <- data[-ind_fold,]
test.solu <- label[ind_fold]
train.solu <- label[-ind_fold]
### Make predictions:
knnprd <- class::knn(train = trainDat, cl = train.solu,
test = testDat, k = KNN_k)
### Combine true solution with predictions:
preds[[i]] <- data.frame("Prediction"=knnprd, "TrueValue"=test.solu)
}
predmrg <- do.call(rbind, preds)
### Confusion matrix:
confm <- table(predmrg)
confm
confm->a
a
### Check input:
stopifnot(nrow(data)==length(label), is.factor(label),
1<k_fold, k_fold<=nrow(data), KNN_k<=nrow(data))
### Create k sub-selections:
n <- nrow(data)
inds <- sample(1:n)
indL <- suppressWarnings(split(inds, f = 1:k_fold))
### Run KNN on each selection:
preds <- list()   # Create empty list
for(i in 1:k_fold){
### Extract fold data:
ind_fold <- indL[[i]]
testDat <- data[ind_fold,]
trainDat <- data[-ind_fold,]
test.solu <- label[ind_fold]
train.solu <- label[-ind_fold]
### Make predictions:
knnprd <- class::knn(train = trainDat, cl = train.solu,
test = testDat, k = KNN_k)
### Combine true solution with predictions:
preds[[i]] <- data.frame("Prediction"=knnprd, "TrueValue"=test.solu)
}
### Merge into one data frame:
### In one command:
# predmrg <- do.call(rbind, preds)
### Using a for loop instead:
predmrg <- preds[[1]]
for(i in 2:length(preds)){
predmrg <- rbind(predmrg, preds[[i]])
}
### Confusion matrix:
confm <- table(predmrg)
a
confm
### Check input:
stopifnot(nrow(data)==length(label), is.factor(label),
1<k_fold, k_fold<=nrow(data), KNN_k<=nrow(data))
### Create k sub-selections:
n <- nrow(data)
inds <- sample(1:n)
indL <- suppressWarnings(split(inds, f = 1:k_fold))
### Run KNN on each selection:
preds <- list()   # Create empty list
for(i in 1:k_fold){
### Extract fold data:
ind_fold <- indL[[i]]
testDat <- data[ind_fold,]
trainDat <- data[-ind_fold,]
test.solu <- label[ind_fold]
train.solu <- label[-ind_fold]
### Make predictions:
knnprd <- class::knn(train = trainDat, cl = train.solu,
test = testDat, k = KNN_k)
### Combine true solution with predictions:
preds[[i]] <- data.frame("TrueValue"=test.solu, "Prediction"=knnprd)
}
### Merge into one data frame:
### In one command:
# predmrg <- do.call(rbind, preds)
### Using a for loop instead:
predmrg <- preds[[1]]
for(i in 2:length(preds)){
predmrg <- rbind(predmrg, preds[[i]])
}
### Confusion matrix:
confm <- table(predmrg)
### Return value:
rval <- list()
confm
### Error rate:
missMat <- confm
diag(missMat) <- 0
missCount <- sum(missMat)
missCount
testErr <- missCount/n
testErr
n
testErr <- missCount/sum(confm)
testErr
### Return value:
rval <- list("ConfusionMatrix"=confm, "MissclassRate"=testErr)
rval
rm(list=ls())
### Create function:
KNN_crossVal <- function(data, label, k_fold=10, KNN_k=1){
### Check input:
stopifnot(nrow(data)==length(label), is.factor(label),
1<k_fold, k_fold<=nrow(data), KNN_k<=nrow(data))
### Create k sub-selections:
n <- nrow(data)
inds <- sample(1:n)
indL <- suppressWarnings(split(inds, f = 1:k_fold))
### Run KNN on each selection:
preds <- list()   # Create empty list
for(i in 1:k_fold){
### Extract fold data:
ind_fold <- indL[[i]]
testDat <- data[ind_fold,]
trainDat <- data[-ind_fold,]
test.solu <- label[ind_fold]
train.solu <- label[-ind_fold]
### Make predictions:
knnprd <- class::knn(train = trainDat, cl = train.solu,
test = testDat, k = KNN_k)
### Combine true solution with predictions:
preds[[i]] <- data.frame("TrueValue"=test.solu, "Prediction"=knnprd)
}
### Merge into one data frame:
### In one command:
# predmrg <- do.call(rbind, preds)
### Using a for loop instead:
predmrg <- preds[[1]]
for(i in 2:length(preds)){
predmrg <- rbind(predmrg, preds[[i]])
}
### Confusion matrix:
confm <- table(predmrg)
### Error rate:
missMat <- confm
diag(missMat) <- 0
missCount <- sum(missMat)
testErr <- missCount/sum(confm)
### Return value:
rval <- list("ConfusionMatrix"=confm, "MissclassRate"=testErr)
return(rval)
}
### Try out function:
dat <- iris[,-5]
label <- iris$Species
KNN_crossVal(data = dat, label = label, k_fold = 10, KNN_k = 5)
# Date: 19-11-2021
#****************#
#   CVFunction   #
#****************#
### Create function:
KNN_crossVal <- function(data, label, k_fold=10, KNN_k=1){
### Check input:
stopifnot(nrow(data)==length(label), is.factor(label),
1<k_fold, k_fold<=nrow(data), KNN_k<=nrow(data))
### Create k sub-selections:
n <- nrow(data)
inds <- sample(1:n)
indL <- suppressWarnings(split(inds, f = 1:k_fold))
### Run KNN on each selection:
preds <- list()   # Create empty list
for(i in 1:k_fold){
### Extract fold data:
ind_fold <- indL[[i]]
testDat <- data[ind_fold,]
trainDat <- data[-ind_fold,]
test.solu <- label[ind_fold]
train.solu <- label[-ind_fold]
### Make predictions:
knnprd <- class::knn(train = trainDat, cl = train.solu,
test = testDat, k = KNN_k)
### Combine true solution with predictions:
preds[[i]] <- data.frame("TrueValue"=test.solu, "Prediction"=knnprd)
}
### Merge into one data frame:
### In one command:
# predmrg <- do.call(rbind, preds)
### Using a for loop instead:
predmrg <- preds[[1]]
for(i in 2:length(preds)){
predmrg <- rbind(predmrg, preds[[i]])
}
### Confusion matrix:
confm <- table(predmrg)
### Error rate:
missMat <- confm
diag(missMat) <- 0
missCount <- sum(missMat)
testErr <- missCount/sum(confm)
### Return value:
rval <- list("ConfusionMatrix"=confm, "MissclassRate"=testErr)
return(rval)
}
### Try out function:
dat <- iris[,-5]
label <- iris$Species
KNN_crossVal(data = dat, label = label, k_fold = 10, KNN_k = 5)
ls()
### Create function:
KNN_crossVal <- function(X, y, k_fold=10, KNN_k=1){
### Check input:
stopifnot(nrow(X)==length(y), is.factor(y),
1<k_fold, k_fold<=nrow(X), KNN_k<=nrow(X))
### Create k sub-selections:
n <- nrow(X)
inds <- sample(1:n)
indL <- suppressWarnings(split(inds, f = 1:k_fold))
### Run KNN on each selection:
preds <- list()   # Create empty list
for(i in 1:k_fold){
### Extract fold data:
ind_fold <- indL[[i]]
testDat <- X[ind_fold,]
trainDat <- X[-ind_fold,]
test.solu <- y[ind_fold]
train.solu <- y[-ind_fold]
### Make predictions:
knnprd <- class::knn(train = trainDat, cl = train.solu,
test = testDat, k = KNN_k)
### Combine true solution with predictions:
preds[[i]] <- data.frame("TrueValue"=test.solu, "Prediction"=knnprd)
}
### Merge into one data frame:
### In one command:
# predmrg <- do.call(rbind, preds)
### Using a for loop instead:
predmrg <- preds[[1]]
for(i in 2:length(preds)){
predmrg <- rbind(predmrg, preds[[i]])
}
### Confusion matrix:
confm <- table(predmrg)
### Error rate:
missMat <- confm
diag(missMat) <- 0
missCount <- sum(missMat)
testErr <- missCount/sum(confm)
### Return value:
rval <- list("ConfusionMatrix"=confm, "MissclassRate"=testErr)
return(rval)
}
### Try out function:
dat <- iris[,-5]
y <- iris$Species
KNN_crossVal(X = dat, y = y, k_fold = 10, KNN_k = 5)
